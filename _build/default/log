prog : testcases/bool_always_false.mls
let rec (f : (bool -> bool)) = 
  fun (x:bool) -> 
    False([])
time(s): 0.00 
mem(Kb): 2732


prog : testcases/bool_always_true.mls
let rec (f : (bool -> bool)) = 
  fun (x:bool) -> 
    True([])
time(s): 0.00 
mem(Kb): 2716


prog : testcases/bool_band.mls
let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      (x).0
    True(_) -> 
      (x).1
    
time(s): 0.01 
mem(Kb): 4700


prog : testcases/bool_bor.mls
let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      (x).1
    True(_) -> 
      (x).0
    
time(s): 0.01 
mem(Kb): 4716


prog : testcases/bool_impl.mls
let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      True([])
    True(_) -> 
      (x).1
    
time(s): 0.01 
mem(Kb): 4700


prog : testcases/bool_neg.mls
let rec (f : (bool -> bool)) = 
  fun (x:bool) -> 
    match x with
    False(_) -> 
      True([])
    True(_) -> 
      False([])
    
time(s): 0.00 
mem(Kb): 3168


prog : testcases/bool_xor.mls
let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      (x).1
    True(_) -> 
      match (x).1 with
      False(_) -> 
        (x).0
      True(_) -> 
        False([])
      
    
time(s): 0.01 
mem(Kb): 4724


prog : testcases/list_append.mls
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).0
    Cons(_) -> 
      match (Un_Cons((x).0)).0 with
      O(_) -> 
        Cons([(Un_Cons((x).0)).0, (x).0])
      S(_) -> 
        Cons([(Un_Cons((x).0)).0, Cons([O([]), (x).1])])
      
    
time(s): 0.03 
mem(Kb): 8640


prog : testcases/list_compress.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        x
      Cons(_) -> 
        match ((compare (Un_Cons((Un_Cons(x)).1)).0) (Un_Cons(x)).0) with
        EQ(_) -> 
          (f (Un_Cons(x)).1)
        GT(_) -> 
          Cons([(Un_Cons(x)).0, (f (Un_Cons(x)).1)])
        LT(_) -> 
          Cons([(Un_Cons(x)).0, (f (Un_Cons(x)).1)])
        
      
    
time(s): 0.12 
mem(Kb): 7452


prog : testcases/list_concat.mls
let rec (f : (llist -> list)) = 
  fun (x:llist) -> 
    match x with
    LNil(_) -> 
      Nil([])
    LCons(_) -> 
      ((append (f (Un_LCons(x)).1)) (Un_LCons(x)).0)
    
time(s): 0.03 
mem(Kb): 6756


prog : testcases/list_drop.mls
let rec (f : ((list, nat) -> list)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).0
    Cons(_) -> 
      match (x).1 with
      O(_) -> 
        (x).0
      S(_) -> 
        (f [(Un_Cons((x).0)).1, Un_S((x).1)])
      
    
time(s): 0.02 
mem(Kb): 8908


prog : testcases/list_even_parity.mls
let rec (f : (list -> bool)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      True([])
    Cons(_) -> 
      match (Un_Cons(x)).0 with
      False(_) -> 
        (f (Un_Cons(x)).1)
      True(_) -> 
        match (Un_Cons(x)).1 with
        Nil(_) -> 
          False([])
        Cons(_) -> 
          (Un_Cons((Un_Cons(x)).1)).0
        
      
    
time(s): 0.01 
mem(Kb): 5008


prog : testcases/list_filter.mls
let rec (f : (((nat -> bool), list) -> list)) = 
  fun (x:((nat -> bool), list)) -> 
    match (x).1 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      match ((x).0 S((Un_Cons((x).1)).0)) with
      False(_) -> 
        (x).1
      True(_) -> 
        match (Un_Cons((x).1)).0 with
        O(_) -> 
          (Un_Cons((x).1)).1
        S(_) -> 
          Cons([O([]), Nil([])])
        
      
    
time(s): 0.02 
mem(Kb): 5320


prog : testcases/list_fold.mls
let rec (f : (((nat -> (nat -> nat)), nat, list) -> nat)) = 
  fun (x:((nat -> (nat -> nat)), nat, list)) -> 
    match (x).2 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      ((count_odd S(((count_odd (Un_Cons((x).2)).0) (Un_Cons((x).2)).0))) (Un_Cons((x).2)).0)
    
time(s): 0.07 
mem(Kb): 9560


prog : testcases/list_hd.mls
let rec (f : (list -> nat)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      O([])
    Cons(_) -> 
      (Un_Cons(x)).0
    
time(s): 0.01 
mem(Kb): 5176


prog : testcases/list_inc.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      Cons([S((Un_Cons(x)).0), (f (Un_Cons(x)).1)])
    
time(s): 0.02 
mem(Kb): 5444


prog : testcases/list_last.mls
let rec (f : (list -> natopt)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      None([])
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        Some((Un_Cons(x)).0)
      Cons(_) -> 
        (f (Un_Cons(x)).1)
      
    
time(s): 0.02 
mem(Kb): 5512


prog : testcases/list_length.mls
let rec (f : (list -> nat)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      O([])
    Cons(_) -> 
      S((f (Un_Cons(x)).1))
    
time(s): 0.01 
mem(Kb): 4904


prog : testcases/list_map.mls
let rec (f : (((nat -> nat), list) -> list)) = 
  fun (x:((nat -> nat), list)) -> 
    match (x).1 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      Cons([((x).0 (Un_Cons((x).1)).0), (f [(x).0, (Un_Cons((x).1)).1])])
    
time(s): 0.02 
mem(Kb): 6468


prog : testcases/list_nth.mls
let rec (f : ((list, nat) -> nat)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      O([])
    Cons(_) -> 
      match (x).1 with
      O(_) -> 
        (Un_Cons((x).0)).0
      S(_) -> 
        (f [(Un_Cons((x).0)).1, Un_S((x).1)])
      
    
time(s): 0.03 
mem(Kb): 8524


prog : testcases/list_pairwise_swap.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        (Un_Cons(x)).1
      Cons(_) -> 
        match (Un_Cons(x)).0 with
        O(_) -> 
          Cons([(Un_Cons((Un_Cons(x)).1)).0, Cons([(Un_Cons(x)).0, Cons([(Un_Cons((Un_Cons(x)).1)).0, Cons([(Un_Cons(x)).0, Nil([])])])])])
        S(_) -> 
          match (Un_Cons((Un_Cons(x)).1)).1 with
          Nil(_) -> 
            Cons([(Un_Cons((Un_Cons(x)).1)).0, Cons([(Un_Cons(x)).0, Nil([])])])
          Cons(_) -> 
            Nil([])
          
        
      
    
time(s): 0.07 
mem(Kb): 6504


prog : testcases/list_rev_append.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        x
      Cons(_) -> 
        ((append (f (Un_Cons((Un_Cons(x)).1)).1)) Cons([(Un_Cons(x)).0, Cons([O([]), Nil([])])]))
      
    
time(s): 0.08 
mem(Kb): 8692


prog : testcases/list_rev_fold.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    (((fold snoc) Nil([])) x)
time(s): 0.00 
mem(Kb): 4692


prog : testcases/list_rev_snoc.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      ((snoc (f (Un_Cons(x)).1)) (Un_Cons(x)).0)
    
time(s): 0.03 
mem(Kb): 7152


prog : testcases/list_rev_tailcall.mls
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).0
    Cons(_) -> 
      match (Un_Cons((x).0)).1 with
      Nil(_) -> 
        (x).0
      Cons(_) -> 
        Cons([S((Un_Cons((x).0)).0), Cons([O([]), (x).1])])
      
    
time(s): 0.01 
mem(Kb): 5164


prog : testcases/list_snoc.mls
let rec (f : ((list, nat) -> list)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      Cons([(x).1, (x).0])
    Cons(_) -> 
      Cons([(Un_Cons((x).0)).0, (f [(Un_Cons((x).0)).1, (x).1])])
    
time(s): 0.02 
mem(Kb): 7016


prog : testcases/list_sort_sorted_insert.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      ((insert (f (Un_Cons(x)).1)) (Un_Cons(x)).0)
    
time(s): 0.03 
mem(Kb): 7500


prog : testcases/list_sorted_insert.mls
let rec (f : ((list, nat) -> list)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      Cons([(x).1, (x).0])
    Cons(_) -> 
      match ((compare (x).1) (Un_Cons((x).0)).0) with
      EQ(_) -> 
        (x).0
      GT(_) -> 
        Cons([(Un_Cons((x).0)).0, (f [(Un_Cons((x).0)).1, (x).1])])
      LT(_) -> 
        Cons([(x).1, (x).0])
      
    
time(s): 0.13 
mem(Kb): 10984


prog : testcases/list_stutter.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      Cons([(Un_Cons(x)).0, Cons([(Un_Cons(x)).0, (f (Un_Cons(x)).1)])])
    
time(s): 0.01 
mem(Kb): 4844


prog : testcases/list_sum.mls
let rec (f : (list -> nat)) = 
  fun (x:list) -> 
    (((fold add) O([])) x)
time(s): 0.00 
mem(Kb): 4700


prog : testcases/list_take.mls
let rec (f : ((nat, list) -> list)) = 
  fun (x:(nat, list)) -> 
    match (x).1 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      match (x).0 with
      O(_) -> 
        Nil([])
      S(_) -> 
        Cons([(Un_Cons((x).1)).0, (f [Un_S((x).0), (Un_Cons((x).1)).1])])
      
    
time(s): 0.02 
mem(Kb): 6604


prog : testcases/list_tl.mls
let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      (Un_Cons(x)).1
    
time(s): 0.01 
mem(Kb): 4864


prog : testcases/nat_add.mls
let rec (f : ((nat, nat) -> nat)) = 
  fun (x:(nat, nat)) -> 
    match (x).0 with
    O(_) -> 
      (x).1
    S(_) -> 
      S((f [Un_S((x).0), (x).1]))
    
time(s): 0.08 
mem(Kb): 25800


prog : testcases/nat_iseven.mls
Fatal error: exception Failure("No solution within depth of 8.")
Command exited with non-zero status 2
time(s): 0.01 
mem(Kb): 4700


prog : testcases/nat_max.mls
let rec (f : ((nat, nat) -> nat)) = 
  fun (x:(nat, nat)) -> 
    match ((compare (x).0) (x).1) with
    EQ(_) -> 
      (x).0
    GT(_) -> 
      (x).0
    LT(_) -> 
      (x).1
    
time(s): 0.15 
mem(Kb): 27816


prog : testcases/nat_pred.mls
let rec (f : (nat -> nat)) = 
  fun (x:nat) -> 
    match x with
    O(_) -> 
      x
    S(_) -> 
      Un_S(x)
    
time(s): 0.01 
mem(Kb): 4688


prog : testcases/tree_binsert.mls
let rec (f : ((tree, nat) -> tree)) = 
  fun (x:(tree, nat)) -> 
    match (x).0 with
    Leaf(_) -> 
      Node([(x).0, (x).1, (x).0])
    Node(_) -> 
      match ((comp_nat (x).1) (Un_Node((x).0)).1) with
      CEq(_) -> 
        (x).0
      CGt(_) -> 
        Node([(Un_Node((x).0)).0, (Un_Node((x).0)).1, (f [(Un_Node((x).0)).2, (x).1])])
      CLt(_) -> 
        Node([(f [(Un_Node((x).0)).0, (x).1]), (Un_Node((x).0)).1, (Un_Node((x).0)).2])
      
    
time(s): 0.71 
mem(Kb): 30116


prog : testcases/tree_collect_leaves.mls
let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append (f (Un_Node(x)).0)) Cons([(Un_Node(x)).1, (f (Un_Node(x)).2)]))
    
time(s): 0.06 
mem(Kb): 6776


prog : testcases/tree_count_leaves.mls
let rec (f : (tree -> nat)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      S(O([]))
    Node(_) -> 
      ((sum (f (Un_Node(x)).0)) (f (Un_Node(x)).2))
    
time(s): 0.06 
mem(Kb): 6440


prog : testcases/tree_count_nodes.mls
let rec (f : (tree -> nat)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      O([])
    Node(_) -> 
      ((sum (f (Un_Node(x)).0)) S((f (Un_Node(x)).2)))
    
time(s): 0.17 
mem(Kb): 21516


prog : testcases/tree_inorder.mls
let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append (f (Un_Node(x)).0)) Cons([(Un_Node(x)).1, (f (Un_Node(x)).2)]))
    
time(s): 0.13 
mem(Kb): 10508


prog : testcases/tree_map.mls
let rec (f : (((nat -> nat), tree) -> tree)) = 
  fun (x:((nat -> nat), tree)) -> 
    match (x).1 with
    Leaf(_) -> 
      (x).1
    Node(_) -> 
      Node([(f [(x).0, (Un_Node((x).1)).0]), ((x).0 (Un_Node((x).1)).1), (f [(x).0, (Un_Node((x).1)).2])])
    
time(s): 0.06 
mem(Kb): 11904


prog : testcases/tree_nodes_at_level.mls
let rec (f : ((tree, nat) -> nat)) = 
  fun (x:(tree, nat)) -> 
    match (x).0 with
    Leaf(_) -> 
      O([])
    Node(_) -> 
      match (x).1 with
      O(_) -> 
        S((x).1)
      S(_) -> 
        ((sum (f [(Un_Node((x).0)).0, Un_S((x).1)])) (f [(Un_Node((x).0)).2, Un_S((x).1)]))
      
    
time(s): 0.36 
mem(Kb): 14708


prog : testcases/tree_postorder.mls
let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append ((append (f (Un_Node(x)).0)) (f (Un_Node(x)).2))) Cons([(Un_Node(x)).1, Nil([])]))
    
time(s): 0.53 
mem(Kb): 23388


prog : testcases/tree_preorder.mls
let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append Cons([(Un_Node(x)).1, (f (Un_Node(x)).0)])) (f (Un_Node(x)).2))
    
time(s): 0.12 
mem(Kb): 12408


