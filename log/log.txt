synthesizer :trio
prog : testcases/basic/bool_always_false.mls

let rec (f : (bool -> bool)) = 
  fun (x:bool) -> 
    False([])
Time(s): 0.03 
Mem(Kb): 2756


synthesizer :trio
prog : testcases/basic/bool_always_true.mls

let rec (f : (bool -> bool)) = 
  fun (x:bool) -> 
    True([])
Time(s): 0.00 
Mem(Kb): 2728


synthesizer :trio
prog : testcases/basic/bool_band.mls

let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      (x).0
    True(_) -> 
      (x).1
    
Time(s): 0.01 
Mem(Kb): 4736


synthesizer :trio
prog : testcases/basic/bool_bor.mls

let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      (x).1
    True(_) -> 
      (x).0
    
Time(s): 0.01 
Mem(Kb): 4724


synthesizer :trio
prog : testcases/basic/bool_impl.mls

let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      True([])
    True(_) -> 
      (x).1
    
Time(s): 0.01 
Mem(Kb): 4736


synthesizer :trio
prog : testcases/basic/bool_neg.mls

let rec (f : (bool -> bool)) = 
  fun (x:bool) -> 
    match x with
    False(_) -> 
      True([])
    True(_) -> 
      False([])
    
Time(s): 0.01 
Mem(Kb): 3156


synthesizer :trio
prog : testcases/basic/bool_xor.mls

let rec (f : ((bool, bool) -> bool)) = 
  fun (x:(bool, bool)) -> 
    match (x).0 with
    False(_) -> 
      (x).1
    True(_) -> 
      match (x).1 with
      False(_) -> 
        (x).0
      True(_) -> 
        False([])
      
    
Time(s): 0.01 
Mem(Kb): 4740


synthesizer :trio
prog : testcases/basic/list_append.mls

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).0
    Cons(_) -> 
      match (Un_Cons((x).0)).0 with
      O(_) -> 
        Cons([(Un_Cons((x).0)).0, (x).0])
      S(_) -> 
        Cons([(Un_Cons((x).0)).0, Cons([O([]), (x).1])])
      
    
Time(s): 0.03 
Mem(Kb): 8708


synthesizer :trio
prog : testcases/basic/list_compress.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        x
      Cons(_) -> 
        match ((compare (Un_Cons((Un_Cons(x)).1)).0) (Un_Cons(x)).0) with
        EQ(_) -> 
          (f (Un_Cons(x)).1)
        GT(_) -> 
          Cons([(Un_Cons(x)).0, (f (Un_Cons(x)).1)])
        LT(_) -> 
          Cons([(Un_Cons(x)).0, (f (Un_Cons(x)).1)])
        
      
    
Time(s): 0.11 
Mem(Kb): 6696


synthesizer :trio
prog : testcases/basic/list_concat.mls

let rec (f : (llist -> list)) = 
  fun (x:llist) -> 
    match x with
    LNil(_) -> 
      Nil([])
    LCons(_) -> 
      ((append (f (Un_LCons(x)).1)) (Un_LCons(x)).0)
    
Time(s): 0.03 
Mem(Kb): 5976


synthesizer :trio
prog : testcases/basic/list_drop.mls

let rec (f : ((list, nat) -> list)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).0
    Cons(_) -> 
      match (x).1 with
      O(_) -> 
        (x).0
      S(_) -> 
        (f [(Un_Cons((x).0)).1, Un_S((x).1)])
      
    
Time(s): 0.02 
Mem(Kb): 8984


synthesizer :trio
prog : testcases/basic/list_even_parity.mls

let rec (f : (list -> bool)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      True([])
    Cons(_) -> 
      match (Un_Cons(x)).0 with
      False(_) -> 
        (f (Un_Cons(x)).1)
      True(_) -> 
        (bnot (f (Un_Cons(x)).1))
      
    
Time(s): 0.01 
Mem(Kb): 5244


synthesizer :trio
prog : testcases/basic/list_filter.mls

let rec (f : (((nat -> bool), list) -> list)) = 
  fun (x:((nat -> bool), list)) -> 
    match (x).1 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      match ((x).0 S((Un_Cons((x).1)).0)) with
      False(_) -> 
        (x).1
      True(_) -> 
        match (Un_Cons((x).1)).0 with
        O(_) -> 
          (Un_Cons((x).1)).1
        S(_) -> 
          Cons([O([]), Nil([])])
        
      
    
Time(s): 0.02 
Mem(Kb): 5336


synthesizer :trio
prog : testcases/basic/list_fold.mls

let rec (f : (((nat -> (nat -> nat)), nat, list) -> nat)) = 
  fun (x:((nat -> (nat -> nat)), nat, list)) -> 
    match (x).2 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      ((count_odd S(((count_odd (Un_Cons((x).2)).0) (Un_Cons((x).2)).0))) (Un_Cons((x).2)).0)
    
Time(s): 0.05 
Mem(Kb): 6128


synthesizer :trio
prog : testcases/basic/list_hd.mls

let rec (f : (list -> nat)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      O([])
    Cons(_) -> 
      (Un_Cons(x)).0
    
Time(s): 0.01 
Mem(Kb): 5212


synthesizer :trio
prog : testcases/basic/list_inc.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      Cons([S((Un_Cons(x)).0), (f (Un_Cons(x)).1)])
    
Time(s): 0.02 
Mem(Kb): 5424


synthesizer :trio
prog : testcases/basic/list_last.mls

let rec (f : (list -> natopt)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      None([])
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        Some((Un_Cons(x)).0)
      Cons(_) -> 
        (f (Un_Cons(x)).1)
      
    
Time(s): 0.02 
Mem(Kb): 5492


synthesizer :trio
prog : testcases/basic/list_length.mls

let rec (f : (list -> nat)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      O([])
    Cons(_) -> 
      S((f (Un_Cons(x)).1))
    
Time(s): 0.01 
Mem(Kb): 4884


synthesizer :trio
prog : testcases/basic/list_map.mls

let rec (f : (((nat -> nat), list) -> list)) = 
  fun (x:((nat -> nat), list)) -> 
    match (x).1 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      Cons([((x).0 (Un_Cons((x).1)).0), (f [(x).0, (Un_Cons((x).1)).1])])
    
Time(s): 0.02 
Mem(Kb): 5688


synthesizer :trio
prog : testcases/basic/list_nth.mls

let rec (f : ((list, nat) -> nat)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      O([])
    Cons(_) -> 
      match (x).1 with
      O(_) -> 
        (Un_Cons((x).0)).0
      S(_) -> 
        (f [(Un_Cons((x).0)).1, Un_S((x).1)])
      
    
Time(s): 0.03 
Mem(Kb): 7416


synthesizer :trio
prog : testcases/basic/list_pairwise_swap.mls

let rec (f : (list -> list)) =
  fun (x:list) ->
    match x with
    Nil(_) ->
      x
    Cons(_) ->
      match (Un_Cons(x)).1 with
      Nil(_) ->
        (Un_Cons(x)).1
      Cons(_) ->
        Cons([(Un_Cons((Un_Cons(x)).1)).0, Cons([(Un_Cons(x)).0, (f (Un_Cons((Un_Cons(x)).1)).1)])])


Time(s): 0.04
Mem(Kb): 5348

synthesizer :trio
prog : testcases/basic/list_rev_append.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        x
      Cons(_) -> 
        ((append (f (Un_Cons((Un_Cons(x)).1)).1)) Cons([(Un_Cons(x)).0, Cons([O([]), Nil([])])]))
      
    
Time(s): 0.07 
Mem(Kb): 6172


synthesizer :trio
prog : testcases/basic/list_rev_fold.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    (((fold snoc) Nil([])) x)
Time(s): 0.01 
Mem(Kb): 4396


synthesizer :trio
prog : testcases/basic/list_rev_snoc.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      ((snoc (f (Un_Cons(x)).1)) (Un_Cons(x)).0)
    
Time(s): 0.03 
Mem(Kb): 6548


synthesizer :trio
prog : testcases/basic/list_rev_tailcall.mls

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).0
    Cons(_) -> 
      match (Un_Cons((x).0)).1 with
      Nil(_) -> 
        (x).0
      Cons(_) -> 
        Cons([S((Un_Cons((x).0)).0), Cons([O([]), (x).1])])
      
    
Time(s): 0.01 
Mem(Kb): 5168


synthesizer :trio
prog : testcases/basic/list_snoc.mls

let rec (f : ((list, nat) -> list)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      Cons([(x).1, (x).0])
    Cons(_) -> 
      Cons([(Un_Cons((x).0)).0, (f [(Un_Cons((x).0)).1, (x).1])])
    
Time(s): 0.02 
Mem(Kb): 7088


synthesizer :trio
prog : testcases/basic/list_sort_sorted_insert.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      ((insert (f (Un_Cons(x)).1)) (Un_Cons(x)).0)
    
Time(s): 0.03 
Mem(Kb): 7156


synthesizer :trio
prog : testcases/basic/list_sorted_insert.mls

let rec (f : ((list, nat) -> list)) = 
  fun (x:(list, nat)) -> 
    match (x).0 with
    Nil(_) -> 
      Cons([(x).1, (x).0])
    Cons(_) -> 
      match ((compare (x).1) (Un_Cons((x).0)).0) with
      EQ(_) -> 
        (x).0
      GT(_) -> 
        Cons([(Un_Cons((x).0)).0, (f [(Un_Cons((x).0)).1, (x).1])])
      LT(_) -> 
        Cons([(x).1, (x).0])
      
    
Time(s): 0.13 
Mem(Kb): 10460


synthesizer :trio
prog : testcases/basic/list_stutter.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      Cons([(Un_Cons(x)).0, Cons([(Un_Cons(x)).0, (f (Un_Cons(x)).1)])])
    
Time(s): 0.01 
Mem(Kb): 4868


synthesizer :trio
prog : testcases/basic/list_sum.mls

let rec (f : (list -> nat)) = 
  fun (x:list) -> 
    (((fold add) O([])) x)
Time(s): 0.01 
Mem(Kb): 4288


synthesizer :trio
prog : testcases/basic/list_take.mls

let rec (f : ((nat, list) -> list)) = 
  fun (x:(nat, list)) -> 
    match (x).1 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      match (x).0 with
      O(_) -> 
        Nil([])
      S(_) -> 
        Cons([(Un_Cons((x).1)).0, (f [Un_S((x).0), (Un_Cons((x).1)).1])])
      
    
Time(s): 0.02 
Mem(Kb): 6684


synthesizer :trio
prog : testcases/basic/list_tl.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      (Un_Cons(x)).1
    
Time(s): 0.01 
Mem(Kb): 4868


synthesizer :trio
prog : testcases/basic/nat_add.mls

let rec (f : ((nat, nat) -> nat)) = 
  fun (x:(nat, nat)) -> 
    match (x).0 with
    O(_) -> 
      (x).1
    S(_) -> 
      S((f [Un_S((x).0), (x).1]))
    
Time(s): 0.08 
Mem(Kb): 23032


synthesizer :trio
prog : testcases/basic/nat_iseven.mls

let rec (f : (nat -> bool)) = 
  fun (x:nat) -> 
    match x with
    O(_) -> 
      True([])
    S(_) -> 
      match Un_S(x) with
      O(_) -> 
        False([])
      S(_) -> 
        (f Un_S(Un_S(x)))
      
    
Time(s): 0.01 
Mem(Kb): 4628


synthesizer :trio
prog : testcases/basic/nat_max.mls

let rec (f : ((nat, nat) -> nat)) = 
  fun (x:(nat, nat)) -> 
    match ((compare (x).0) (x).1) with
    EQ(_) -> 
      (x).0
    GT(_) -> 
      (x).0
    LT(_) -> 
      (x).1
    
Time(s): 0.14 
Mem(Kb): 25296


synthesizer :trio
prog : testcases/basic/nat_pred.mls

let rec (f : (nat -> nat)) = 
  fun (x:nat) -> 
    match x with
    O(_) -> 
      x
    S(_) -> 
      Un_S(x)
    
Time(s): 0.01 
Mem(Kb): 4720


synthesizer :trio
prog : testcases/basic/tree_binsert.mls

let rec (f : ((tree, nat) -> tree)) = 
  fun (x:(tree, nat)) -> 
    match (x).0 with
    Leaf(_) -> 
      Node([(x).0, (x).1, (x).0])
    Node(_) -> 
      match ((comp_nat (x).1) (Un_Node((x).0)).1) with
      CEq(_) -> 
        (x).0
      CGt(_) -> 
        Node([(Un_Node((x).0)).0, (Un_Node((x).0)).1, (f [(Un_Node((x).0)).2, (x).1])])
      CLt(_) -> 
        Node([(f [(Un_Node((x).0)).0, (x).1]), (Un_Node((x).0)).1, (Un_Node((x).0)).2])
      
    
Time(s): 0.68 
Mem(Kb): 26172


synthesizer :trio
prog : testcases/basic/tree_collect_leaves.mls

let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append (f (Un_Node(x)).0)) Cons([(Un_Node(x)).1, (f (Un_Node(x)).2)]))
    
Time(s): 0.06 
Mem(Kb): 6964


synthesizer :trio
prog : testcases/basic/tree_count_leaves.mls

let rec (f : (tree -> nat)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      S(O([]))
    Node(_) -> 
      ((sum (f (Un_Node(x)).0)) (f (Un_Node(x)).2))
    
Time(s): 0.05 
Mem(Kb): 5792


synthesizer :trio
prog : testcases/basic/tree_count_nodes.mls

let rec (f : (tree -> nat)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      O([])
    Node(_) -> 
      ((sum (f (Un_Node(x)).0)) S((f (Un_Node(x)).2)))
    
Time(s): 0.16 
Mem(Kb): 19012


synthesizer :trio
prog : testcases/basic/tree_inorder.mls

let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append (f (Un_Node(x)).0)) Cons([(Un_Node(x)).1, (f (Un_Node(x)).2)]))
    
Time(s): 0.13 
Mem(Kb): 8752


synthesizer :trio
prog : testcases/basic/tree_map.mls

let rec (f : (((nat -> nat), tree) -> tree)) = 
  fun (x:((nat -> nat), tree)) -> 
    match (x).1 with
    Leaf(_) -> 
      (x).1
    Node(_) -> 
      Node([(f [(x).0, (Un_Node((x).1)).0]), ((x).0 (Un_Node((x).1)).1), (f [(x).0, (Un_Node((x).1)).2])])
    
Time(s): 0.05 
Mem(Kb): 9640


synthesizer :trio
prog : testcases/basic/tree_nodes_at_level.mls

let rec (f : ((tree, nat) -> nat)) = 
  fun (x:(tree, nat)) -> 
    match (x).0 with
    Leaf(_) -> 
      O([])
    Node(_) -> 
      match (x).1 with
      O(_) -> 
        S((x).1)
      S(_) -> 
        ((sum (f [(Un_Node((x).0)).0, Un_S((x).1)])) (f [(Un_Node((x).0)).2, Un_S((x).1)]))
      
    
Time(s): 0.33 
Mem(Kb): 13896


synthesizer :trio
prog : testcases/basic/tree_postorder.mls

let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append ((append (f (Un_Node(x)).0)) (f (Un_Node(x)).2))) Cons([(Un_Node(x)).1, Nil([])]))
    
Time(s): 0.47 
Mem(Kb): 20456


synthesizer :trio
prog : testcases/basic/tree_preorder.mls

let rec (f : (tree -> list)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      Nil([])
    Node(_) -> 
      ((append Cons([(Un_Node(x)).1, (f (Un_Node(x)).0)])) (f (Un_Node(x)).2))
    
Time(s): 0.11 
Mem(Kb): 8584


synthesizer :trio
prog : testcases/new/expr_b.mls

let rec (f : (formula -> bool)) = 
  fun (x:formula) -> 
    match x with
    BOOL(_) -> 
      Un_BOOL(x)
    NOT(_) -> 
      (bnot (f Un_NOT(x)))
    ANDALSO(_) -> 
      ((band (f (Un_ANDALSO(x)).0)) (f (Un_ANDALSO(x)).1))
    IMPLY(_) -> 
      ((bor (f (Un_IMPLY(x)).1)) (bnot (f (Un_IMPLY(x)).0)))
    ORELSE(_) -> 
      ((bor (f (Un_ORELSE(x)).0)) (f (Un_ORELSE(x)).1))
    
Time(s): 17.41 
Mem(Kb): 53764


synthesizer :trio
prog : testcases/new/expr.mls

let rec (f : (exp -> nat)) = 
  fun (x:exp) -> 
    match x with
    INT(_) -> 
      Un_INT(x)
    ADD(_) -> 
      ((add (f (Un_ADD(x)).0)) (f (Un_ADD(x)).1))
    MUL(_) -> 
      ((mul (f (Un_MUL(x)).0)) (f (Un_MUL(x)).1))
    
Time(s): 0.85 
Mem(Kb): 25936


synthesizer :trio
prog : testcases/new/expr_sub.mls

let rec (f : (exp -> nat)) = 
  fun (x:exp) -> 
    match x with
    INT(_) -> 
      Un_INT(x)
    ADD(_) -> 
      ((add (f (Un_ADD(x)).0)) (f (Un_ADD(x)).1))
    MUL(_) -> 
      ((mul (f (Un_MUL(x)).0)) (f (Un_MUL(x)).1))
    SUB(_) -> 
      ((sub (f (Un_SUB(x)).0)) (f (Un_SUB(x)).1))
    
Time(s): 17.76 
Mem(Kb): 37200


synthesizer :trio
prog : testcases/new/expr_div.mls

Command exited with non-zero status 124
Time(s): 120.00 
Mem(Kb): 90620


synthesizer :trio
prog : testcases/new/list_dropeven.mls

let rec (f : (list -> list)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      x
    Cons(_) -> 
      match (is_even (Un_Cons(x)).0) with
      False(_) -> 
        Cons([(Un_Cons(x)).0, (f (Un_Cons(x)).1)])
      True(_) -> 
        (Un_Cons(x)).1
      
    
Time(s): 0.01 
Mem(Kb): 5492


synthesizer :trio
prog : testcases/new/list_last2.mls

let rec (f : (list -> natopt)) = 
  fun (x:list) -> 
    match x with
    Nil(_) -> 
      None([])
    Cons(_) -> 
      match (Un_Cons(x)).1 with
      Nil(_) -> 
        None([])
      Cons(_) -> 
        match (Un_Cons((Un_Cons(x)).1)).1 with
        Nil(_) -> 
          Some([(Un_Cons(x)).0, (Un_Cons((Un_Cons(x)).1)).0])
        Cons(_) -> 
          (f (Un_Cons(x)).1)
        
      
    
Time(s): 0.02 
Mem(Kb): 6444


synthesizer :trio
prog : testcases/new/list_make.mls

let rec (f : (nat -> list)) = 
  fun (x:nat) -> 
    match x with
    O(_) -> 
      Nil([])
    S(_) -> 
      Cons([O([]), (f Un_S(x))])
    
Time(s): 0.01 
Mem(Kb): 5300


synthesizer :trio
prog : testcases/new/list_range.mls

let rec (f : ((nat, nat) -> list)) = 
  fun (x:(nat, nat)) -> 
    match (x).0 with
    O(_) -> 
      Cons([(x).0, Nil([])])
    S(_) -> 
      match ((compare (x).1) Un_S((x).0)) with
      EQ(_) -> 
        Cons([(x).0, Cons([(x).1, Nil([])])])
      GT(_) -> 
        Cons([(x).0, Nil([])])
      LT(_) -> 
        Cons([(x).0, (f [Un_S((x).0), (x).1])])
      
    
Time(s): 0.16 
Mem(Kb): 18544


synthesizer :trio
prog : testcases/new/nat_mul.mls

let rec (f : ((nat, nat) -> nat)) = 
  fun (x:(nat, nat)) -> 
    match (x).1 with
    O(_) -> 
      (x).1
    S(_) -> 
      ((add (f [Un_S((x).1), (x).0])) (x).0)
    
Time(s): 1.05 
Mem(Kb): 28996


synthesizer :trio
prog : testcases/new/nat_sub.mls

let rec (f : ((nat, nat) -> nat)) = 
  fun (x:(nat, nat)) -> 
    match (x).0 with
    O(_) -> 
      (x).0
    S(_) -> 
      match (x).1 with
      O(_) -> 
        (x).0
      S(_) -> 
        (f [Un_S((x).0), Un_S((x).1)])
      
    
Time(s): 0.08 
Mem(Kb): 23024


synthesizer :trio
prog : testcases/new/tree_balanced.mls

let rec (f : (tree -> bool)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      True([])
    Node(_) -> 
      match (Un_Node(x)).1 with
      Leaf(_) -> 
        True([])
      Node(_) -> 
        match ((compare (height (Un_Node((Un_Node(x)).1)).2)) S(O([]))) with
        EQ(_) -> 
          True([])
        GT(_) -> 
          False([])
        LT(_) -> 
          match (Un_Node((Un_Node(x)).1)).1 with
          Leaf(_) -> 
            True([])
          Node(_) -> 
            False([])
          
        
      
    
Time(s): 96.00 
Mem(Kb): 61004


synthesizer :trio
prog : testcases/new/tree_height.mls

let rec (f : (tree -> nat)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      O([])
    Node(_) -> 
      match (Un_Node(x)).2 with
      Leaf(_) -> 
        S((f (Un_Node(x)).1))
      Node(_) -> 
        ((max S((f (Un_Node(x)).2))) S(S((f (Un_Node(x)).1))))
      
    
Time(s): 4.46 
Mem(Kb): 25932


synthesizer :trio
prog : testcases/new/tree_lastleft.mls

let rec (f : (tree -> nat)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      O([])
    Node(_) -> 
      match (Un_Node(x)).1 with
      Leaf(_) -> 
        (Un_Node(x)).0
      Node(_) -> 
        (f (Un_Node(x)).1)
      
    
Time(s): 0.23 
Mem(Kb): 18444


synthesizer :trio
prog : testcases/new/tree_notexist.mls

let rec (f : ((nat, tree) -> bool)) = 
  fun (x:(nat, tree)) -> 
    match (x).1 with
    Leaf(_) -> 
      True([])
    Node(_) -> 
      match ((compare (Un_Node((x).1)).0) (x).0) with
      EQ(_) -> 
        False([])
      GT(_) -> 
        ((band (f [(x).0, (Un_Node((x).1)).1])) (f [(x).0, (Un_Node((x).1)).2]))
      LT(_) -> 
        ((band (f [(x).0, (Un_Node((x).1)).1])) (f [(x).0, (Un_Node((x).1)).2]))
      
    
Time(s): 0.37 
Mem(Kb): 15220


synthesizer :trio
prog : testcases/new/tree_sum.mls

let rec (f : (tree -> nat)) = 
  fun (x:tree) -> 
    match x with
    Leaf(_) -> 
      O([])
    Node(_) -> 
      ((add (f (Un_Node(x)).1)) ((add (f (Un_Node(x)).2)) (Un_Node(x)).0))
    
Time(s): 0.45 
Mem(Kb): 20780


